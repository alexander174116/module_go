Пример работы со строками:
func ExampleString() {
	// Создадим строковый литерал s, значение которого "Это строка".
	// Строка состоит из 10 символов, но её длина в байтах будет 19,
	// так как кириллические символы занимают 2 байта, а пробел — 1 байт.
	var s string = "Это строка"

	fmt.Printf("Длина строки: %d байт\n", len(s))

	// Получим подстроку строки
	fmt.Printf("Напечатаем только второе слово в кавычках: \"%v\"\n", s[7:])

	// Попробуем изменить строку (возникнет ошибка компиляции, так как строки неизменяемы):
	// s[3] = 12
	// Ошибка компиляции: cannot assign to s[3], потому что строки - неизменяемые последовательности.

	// "Изменим строку", создав новую строку
	s = s + " Новая строка"
	fmt.Printf("%v\n", s)

	// Проитерируемся по строке
	for _, b := range s {
		fmt.Printf("%v ", b)
	}
	fmt.Print("\n")

	// Output:
	// Длина строки: 19 байт
	// Напечатаем только второе слово в кавычках: "строка"
	// Это строка Новая строка
	// 1069 1090 1086 32 1089 1090 1088 1086 1082 1072 32 1053 1086 1074 1072 1103 32 1089 1090 1088 1086 1082 1072
}               
В данном примере мы создаем строку с кириллическими символами. Обратите внимание, что длина строки в байтах больше, чем количество символов. 
Это связано с тем, что в UTF-8 один символ может занимать более одного байта, в отличие от обычных латинских символов, которые занимают один байт.
Теперь рассмотрим сравнение строк. В Go строки можно сравнивать на равенство или неравенство, используя операторы == и !=, 
но при этом важно помнить, что операторы < и > сравнивают строки по байтам, а не по символам. Таким образом, результат может быть не таким, как ожидалось, если строки содержат символы в разных кодировках.
func ExampleEqualString() {
	// Сравнение строк на равенство
	fmt.Printf("Сравнение на равенство строк \"строка1\" и \"строка2\": %v\n", "строка1" == "строка2")
	
	// Сравнение строк на неравенство
	fmt.Printf("Сравнение на неравенство строк \"строка1\" и \"строка2\": %v\n", "строка1" != "строка2")

	// Сравнение строк по алфавиту
	fmt.Printf("\"Строка1\" > \"Строка2\": %v\n", "Строка1" > "Строка2")

	// Output:
	// Сравнение на равенство строк "строка1" и "строка2": false
	// Сравнение на неравенство строк "строка1" и "строка2": true
	// "Строка1" > "Строка2": false
}          
В примере выше строки сравниваются на равенство и неравенство, а также с использованием оператора > для проверки, какая строка "больше". Однако это сравнение выполняется побайтово, и результат может не 
совпадать с ожидаемым при сравнении строк с различными кодировками или символами.

import "strings"
        // Содержится ли подстрока в строке    
        strings.Contains("test", "es"), 
        // результат: true

        // Кол-во подстрок в строке
        strings.Count("test", "t"),
        // результат: 2

        // Начинается ли строка с префикса       
        strings.HasPrefix("test", "te"), 
        // результат: true

        // Заканчивается ли строка суффиксом
        strings.HasSuffix("test", "st"), 
        // результат: true

        // Возвращает начальный индекс подстроки в строке, а при отсутствии вхождения возвращает -1
        strings.Index("test", "e"), 
        // результат: 1

        // объединяет массив строк через символ
        strings.Join([]string{"hello","world"}, "-"),
        // результат: "hello-world"

        // Повторяет строку n раз подряд
        strings.Repeat("a", 5), 
        // результат: "aaaaa"

        // Функция Replace заменяет любое вхождение old в вашей строке на new
        // Если значение n равно -1, то будут заменены все вхождения.
        // Общий вид: func Replace(s, old, new string, n int) string
        // Пример:
        strings.Replace("blanotblanot", "not", "***", 	-1),
        // результат: "bla***bla***"
 
        // Разбивает строку согласно разделителю
        strings.Split("a-b-c-d-e", "-"), 
        // результат: []string{"a","b","c","d","e"}

        // Возвращает строку c нижним регистром
        strings.ToLower("TEST"), 
        // результат: "test"

        // Возвращает строку c верхним регистром
        strings.ToUpper("test"), 
        // результат: "TEST"

        // Возвращает строку с вырезанным набором
        strings.Trim("tetstet", "te"),
        // результат: s

import "unicode"
    // функции ниже принимают на вход тип rune


    // проверка символа на цифру
	fmt.Println(unicode.IsDigit('1')) // true
    // проверка символа на букву
	fmt.Println(unicode.IsLetter('a')) // true 
    // проверка символа на нижний регистр
	fmt.Println(unicode.IsLower('A')) // false
    // проверка символа на верхний регистр
	fmt.Println(unicode.IsUpper('A')) // true
    // проверка символа на пробел 
    // пробел это не только ' ', но и:
    //  '\t', '\n', '\v', '\f', '\r' - подробнее читайте в документации
	fmt.Println(unicode.IsSpace('\t')) // true 

    // С помощью функции Is можно проверять на кастомный RangeTable:
    // например, проверка на латиницу:
 	fmt.Println(unicode.Is(unicode.Latin, 'ы')) // false


    // функции преобразований
	fmt.Println(string(unicode.ToLower('F'))) // f
	fmt.Println(string(unicode.ToUpper('f'))) // F




Пример работы с байтовым срезом:
func ExampleByteSlice() {
	// Используем строку, которую конвертируем в []byte,
	// чтобы показать, как выглядит байтовый срез.
	bs := []byte("Это байтовый срез")

	// Печатаем байтовый срез.
	fmt.Printf("Так байтовый срез выглядит внутри: %v\n", bs)

	// Демонстрируем, что байтовый срез можно изменять,
	// а затем выводим его в виде строки.
	for i := range bs {
		// Для чётных байтов увеличиваем на 1, для нечётных уменьшаем на 1.
		if bs[i]%2 == 0 {
			bs[i] = bs[i] + 1
		} else {
			bs[i] = bs[i] - 1
		}
	}

	// Печатаем изменённый байтовый срез в виде строки.
	fmt.Printf("Изменённый байтовый срез в виде строки: %s", bs)

	// Output:
	// Так байтовый срез выглядит внутри: [208 173 209 130 208 190 32 208 177 208 176 208 185 209 130 208 190 208 178 209 139 208 185 32 209 129 209 128 208 181 208 183]
	// Изменённый байтовый срез в виде строки: ѬЃѿ!ѰѱѸЃѿѳЊѸ!ЀЁѴѶ
}


func main() {
	var en = "english"
	var ru = "русский"
	fmt.Println(len(en), len(ru))
	fmt.Println(utf8.RuneCountInString(en), utf8.RuneCountInString(ru))
}
Вывод будет такой:
​​​​​​​7 14 // en -7 байтов, ru - 14 байтов
7 7 // а длина у строк одинаковая